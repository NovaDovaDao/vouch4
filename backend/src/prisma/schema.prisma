// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "./generated"
  runtime  = "nodejs"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Core Tenant Model ---
// Represents the top-level gym owner or LLC. Your primary tenant identifier.

model Tenancy {
  id           String   @id @default(uuid())
  name         String // e.g., "MegaGym Holdings"
  legalName    String? // Optional: For separate legal entities for the overarching group
  contactEmail String   @unique // Contact email for the tenancy
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  gyms                 Gym[] // A tenancy can have multiple gyms/locations
  users                User[] // Users (members primarily, or staff whose primary affiliation is here)
  products             Product[] // Products are defined at the tenancy level
  UserTenancyAgreement UserTenancyAgreement[]

  // The User account that *is* the TENANCY_OWNER for this Tenancy
  tenancyOwnerUser   User?   @relation("TenancyOwnerAccount", fields: [tenancyOwnerUserId], references: [id])
  tenancyOwnerUserId String? @unique

  @@map("tenants")
}

// --- Gym/Location Model ---
// Represents a single physical gym location under a Tenancy

model Gym {
  id              String   @id @default(uuid())
  name            String
  address         Json // Flexible JSON for street, city, state, zip, etc.
  tenancyId       String // Foreign key to the Tenancy
  legalEntityName String? // Optional: If each gym has its own legal entity name
  legalDocsUrl    String? // Optional: Link to legal documents
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relationships
  tenancy          Tenancy              @relation(fields: [tenancyId], references: [id])
  classTemplates   ClassTemplate[]
  userAssociations UserGymAssociation[] // Many-to-many for users associated with this specific gym
  checkIns         CheckIn[] // Check-ins are specific to a gym

  @@map("gyms")
}

// --- User Model ---
// Represents a single person with their core identity and all relevant attributes

enum UserCategory {
  MEMBER // A user whose primary interaction is as a gym member
  STAFF // A user who performs staff functions (manager, trainer, route setter, front desk, etc.)

  @@map("user_categories")
}

model User {
  id          String       @id @default(uuid())
  email       String       @unique
  firstName   String
  lastName    String
  category    UserCategory // High-level categorization (MEMBER or STAFF)
  isSuperUser Boolean      @default(false) // True if this user is a Super Admin (replaces SUPER_ADMIN role)
  isActive    Boolean      @default(false) // For disabling user accounts
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  walletAddress String? @unique // Optional, a user might link their wallet later
  phoneNumber   String?

  tenancyId String?
  tenancy   Tenancy? @relation(fields: [tenancyId], references: [id])

  ownedTenancy Tenancy? @relation("TenancyOwnerAccount") // If this user IS the TENANCY_OWNER for a Tenancy

  userGymAssociations UserGymAssociation[]

  checkIns             CheckIn[]       @relation("UserCheckIns") // Check-ins performed by this user
  bookings             Booking[] // Class bookings made by this user
  classTemplatesTaught ClassTemplate[]

  // Entitlements (replaces MembershipNFTs)
  entitlements       Entitlement[] @relation("OwnedEntitlements") // Entitlements owned by this user
  rentedEntitlements Entitlement[] @relation("RentedEntitlements") // Entitlements this user is currently renting

  invitationToken InvitationToken?

  userTenancyAgreements UserTenancyAgreement[]

  name          String?
  emailVerified Boolean
  image         String?
  sessions      Session[]
  accounts      Account[]

  @@map("users")
}

// --- Join Table for User-Gym Association (for Per-Gym Roles & Permissions) ---

enum UserAtGymRole {
  MANAGER
  TRAINER
  ROUTE_SETTER
  FRONT_DESK_STAFF
  CLEANING_STAFF

  @@map("user_at_gym_role_enums")
}

model UserGymAssociation {
  userId        String
  gymId         String
  roleAtGym     UserAtGymRole
  permissions   Json?
  isActiveAtGym Boolean       @default(true)
  assignedAt    DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  user User @relation(fields: [userId], references: [id])
  gym  Gym  @relation(fields: [gymId], references: [id])

  @@id([userId, gymId])
  @@map("user_gym_associations")
}

// --- Check-In Model ---

model CheckIn {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  gymId     String   @map("gym_id")
  timestamp DateTime @default(now())
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation("UserCheckIns", fields: [userId], references: [id])
  gym  Gym  @relation(fields: [gymId], references: [id])

  // If a check-in consumed a pass, this links to the record of that use
  entitlementUse EntitlementUse?

  @@map("check_ins")
}

// --- NEW: Product & Entitlement System (Replaces MembershipNFT) ---

// A Product is a template for something a gym offers (e.g., "Gold Membership", "10-Visit Punch Card").
model Product {
  id        String  @id @default(uuid())
  tenancyId String
  tenancy   Tenancy @relation(fields: [tenancyId], references: [id])

  name   String
  meta   Json?
  active Boolean @default(true) // Is this product available for purchase/granting?

  // Flexible rules engine defining what this product grants.
  // e.g., { type: 'subscription', duration: '1_month' }
  // e.g., { type: 'punch_card', uses: 10 }
  // e.g., { type: 'access', amenity: 'sauna' }
  rules Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  entitlements Entitlement[]

  @@map("products")
}

// An Entitlement is an instance of a Product that a user owns.
model Entitlement {
  id        String  @id @default(uuid())
  productId String
  product   Product @relation(fields: [productId], references: [id])

  ownerId String
  owner   User   @relation("OwnedEntitlements", fields: [ownerId], references: [id])

  // State of this specific entitlement
  validFrom DateTime
  expiresAt DateTime?
  usesLeft  Int?
  meta      Json?
  renterId  String?
  renter    User?     @relation("RentedEntitlements", fields: [renterId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  uses EntitlementUse[]

  @@map("entitlements")
}

// A record of a single use of an Entitlement, usually linked to a CheckIn.
model EntitlementUse {
  id            String      @id @default(uuid())
  entitlementId String
  entitlement   Entitlement @relation(fields: [entitlementId], references: [id])

  checkInId String  @unique
  checkIn   CheckIn @relation(fields: [checkInId], references: [id])

  usedAt DateTime @default(now())

  @@map("entitlement_uses")
}

// --- Class Model ---

model ClassTemplate {
  id           String   @id @default(uuid())
  name         String
  metadata     Json
  gymId        String
  instructorId String?
  recurrence   String // e.g., "6 * 1 * *"
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  gym              Gym              @relation(fields: [gymId], references: [id])
  instructor       User?            @relation(fields: [instructorId], references: [id])
  scheduledClasses ScheduledClass[]

  @@map("class_templates")
}

model ScheduledClass {
  id              String   @id @default(uuid())
  classTemplateId String
  startTime       DateTime
  endTime         DateTime
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  classTemplate ClassTemplate @relation(fields: [classTemplateId], references: [id])
  bookings      Booking[]

  @@map("scheduled_classes")
}

// --- Booking Model ---

model Booking {
  id               String   @id @default(uuid())
  userId           String
  scheduledClassId String
  bookedAt         DateTime @default(now())

  user           User           @relation(fields: [userId], references: [id])
  scheduledClass ScheduledClass @relation(fields: [scheduledClassId], references: [id])

  @@unique([userId, scheduledClassId])
  @@map("bookings")
}

// --- Invitation Token Model ---

model InvitationToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String   @unique // One token per user being invited
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@map("invitation_tokens")
}

// --- NEW MODEL: UserTenancyAgreement ---
// Captures specific agreements (like waivers, terms of service) between a User and a Tenancy.

enum AgreementType {
  WAIVER
  TERMS_OF_SERVICE
  PRIVACY_POLICY
  // Add other agreement types as needed
}

enum AgreementStatus {
  PENDING_SIGNATURE // Waiting for the user to sign
  SIGNED // Agreement has been signed
  EXPIRED // Agreement has an expiration date and is past it
  REVOKED // Agreement was signed but later revoked/invalidated
}

model UserTenancyAgreement {
  id              String          @id @default(uuid())
  userId          String
  tenancyId       String
  type            AgreementType // e.g., WAIVER, TERMS_OF_SERVICE
  status          AgreementStatus @default(PENDING_SIGNATURE)
  documentHash    String?         @map("document_hash") // Hash of the specific version of the document signed
  documentVersion String?         @map("document_version") // e.g., "1.0", "2024-01-01". Allows for multiple versions of agreements.
  signedAt        DateTime? // Timestamp when the agreement was signed
  expiresAt       DateTime? // Optional: for agreements that expire (e.g., annual waivers)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  user    User    @relation(fields: [userId], references: [id])
  tenancy Tenancy @relation(fields: [tenancyId], references: [id])

  // A user signs a specific version of an agreement for a tenancy once
  @@unique([userId, tenancyId, type, documentVersion])
  @@map("user_tenancy_agreements")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("sessions")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("accounts")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verifications")
}
